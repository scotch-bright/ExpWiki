<!DOCTYPE html>
<html>
<head>
	<title>Merge Sort :: A Visual Demo By Khoj Badami</title>
	<style type="text/css">
		canvas {
			border: 1px solid lightgrey;
		}
	</style>
</head>
<body>
	<script src="./libs/jquery-3.5.1.min.js"></script>
	<script src="./libs/matter.min.js"></script>
	<script src="./libs/decomp.min.js"></script>
	<script src="./libs/path-data-polyfill.js"></script>
	<script src="./merge-sort-resources/matterJSBodyBuilders.js"></script>
	
	<script type="text/javascript">
		let allBodies = {};
		let currentIndexOfActionWhenBodiesStopMoving = 0;
		let numbersToBeSorted = [];
		let numberOfSplits = 0;
	</script>

	<script src="./merge-sort-resources/matterJSWorldSetup.js"></script>
	<script src="./merge-sort-resources/utilityFunctions.js"></script>
	<script type="text/javascript">

		function removeBodyFromWorldAndBodiesArray(bodyName) {
			if (allBodies[bodyName] == undefined) return;
			World.remove(world, allBodies[bodyName]);
			delete allBodies[bodyName];
		}

		function removeArrayOfBodies(arrayOfBodies) {
			arrayOfBodies.forEach((bodyName) => removeBodyFromWorldAndBodiesArray(bodyName));
		}

		function removeTwoBodiesOneAfterTheOther(body1Name, body2Name) {
			removeBodyFromWorldAndBodiesArray(body1Name);
			setTimeout(() => removeBodyFromWorldAndBodiesArray(body2Name), 1000);
		}

		function compareTwoPlatformsAndBreak(platform1Name, platform2Name) {
			let v1 = findClosestCircleValueToPlank(allBodies[platform1Name]);
			let v2 = findClosestCircleValueToPlank(allBodies[platform2Name]);
			if (v1 < v2) {
				removeArrayOfBodies([platform1Name]);
			}
			else {
				removeArrayOfBodies([platform2Name]);
			}
		}

		function mergeOperationBasedOnPlatformsArrays(platformArray1, platformArray2) {
			let pi = 0;
			let pj = 0;
			while (platformArray1[pi] != undefined || platformArray2[pj] != undefined) {

				if (platformArray1[pi] == undefined) {
					let idx = pj;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray2[idx]);
					});
					pj += 1;
					continue;
				}

				if (platformArray2[pj] == undefined) {
					let idx = pi;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray1[idx]);
					});
					pi += 1;
					continue;
				}

				let p1Val = findClosestCircleValueToPlank(allBodies[platformArray1[pi]]);
				let p2Val = findClosestCircleValueToPlank(allBodies[platformArray2[pj]]);

				if (p1Val < p2Val) {
					let idx = pi;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray1[idx]);
					});
					pi += 1;
					continue;
				}
				else {
					let idx = pj;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray2[idx]);
					});
					pj += 1;
					continue;
				}

			}
		}

		let actionsWhenObjectsStopMoving = [
			() => {
				removeArrayOfBodies(
					[
						"l0Platform1",
						"l0Platform2",
						"l0Stopper1",
						"l0Stopper2"
					]
				);
			},
			() => {
				removeArrayOfBodies([
					"level2_p2",
					"level2_p3",
					"level2_s2",
					"level2_s3",
					"level2_p4",
					"level2_s4",
					"level2_p1",
					"level2_s1"
				]);
			},
			() => {
				let v1 = findClosestCircleValueToPlank(allBodies.l2p2);
				let v2 = findClosestCircleValueToPlank(allBodies.l2p3);
				if (v1 < v2) {
					removeTwoBodiesOneAfterTheOther("l2p2", "l2p3");
				}
				else {
					removeTwoBodiesOneAfterTheOther("l2p3", "l2p2");
				}
			},
			() => {
				removeArrayOfBodies(["rect1027"]);
			},
			() => {
				compareTwoPlatformsAndBreak("rect57", "rect70");
			},
			() => {
				if (allBodies["rect57"] == undefined) {
					compareTwoPlatformsAndBreak("rect55", "rect70");
				}
				else {
					compareTwoPlatformsAndBreak("rect57", "rect55");
				}
			},
			() => {
				removeArrayOfBodies(["rect55", "rect70", "rect57"]);
			},
			() => {
				let v1 = findClosestCircleValueToPlank(allBodies.l2p4);
				let v2 = findClosestCircleValueToPlank(allBodies.l2p5);
				if (v1 < v2) {
					removeTwoBodiesOneAfterTheOther("l2p4", "l2p5");
				}
				else {
					removeTwoBodiesOneAfterTheOther("l2p5", "l2p4");
				}
			},
			() => {
				removeArrayOfBodies(["rect1033"]);
			},
			() => {
				compareTwoPlatformsAndBreak("rect110", "rect108");
			},
			() => {
				if (allBodies["rect108"] == undefined) {
					compareTwoPlatformsAndBreak("rect110", "rect112");
				}
				else {
					compareTwoPlatformsAndBreak("rect112", "rect108");
				}
			},
			() => {
				removeArrayOfBodies(["rect108", "rect110", "rect112"]);
			},
			() => {
				mergeOperationBasedOnPlatformsArrays(
					["rect132", "rect130", "rect128"],
					["rect88", "rect86", "rect84"]
				);
			}
		]

	</script>
</body>
</html>