<!DOCTYPE html>
<html>
<head>
	<title>Merge Sort :: A Visual Demo By Khoj Badami</title>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/sweetalert2@9"></script>
	<style type="text/css">
		body {
			background-color: #06AED5;
		}
		canvas {
			margin-left: auto;
			margin-right: auto;
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="row">
			<div class="col-sm-12 mt-3">
				<h1 class="text-center text-white mb-4">
					Merge Sort Demo
				</h1>
				<h5 class="text-center text-white">
					By Khoj Badami
				</h5>
			</div>
			<div id="where_the_canvas_comes" class="col-sm-12 text-center text-white mt-3">
			</div>
		</div>
	</div>
	<script src="./libs/jquery-3.5.1.min.js"></script>
	<script src="./libs/matter.min.js"></script>
	<script src="./libs/decomp.min.js"></script>
	<script src="./libs/path-data-polyfill.js"></script>
	<script src="./merge-sort-resources/matterJSBodyBuilders.js"></script>
	
	<script type="text/javascript">
		let allBodies = {};
		let currentIndexOfActionWhenBodiesStopMoving = 0;
		let numbersToBeSorted = [];
		let numberOfSplits = 0;
	</script>

	<script src="./merge-sort-resources/matterJSWorldSetup.js"></script>
	<script src="./merge-sort-resources/utilityFunctions.js"></script>
	<script type="text/javascript">

		function speak(message) {
			var msg = new SpeechSynthesisUtterance(message);
			var voices = window.speechSynthesis.getVoices();
			msg.voice = voices[2];
			window.speechSynthesis.speak(msg);
		}

		function removeBodyFromWorldAndBodiesArray(bodyName) {
			if (allBodies[bodyName] == undefined) return;
			World.remove(world, allBodies[bodyName]);
			delete allBodies[bodyName];
		}

		function removeArrayOfBodies(arrayOfBodies) {
			arrayOfBodies.forEach((bodyName) => removeBodyFromWorldAndBodiesArray(bodyName));
		}

		function removeTwoBodiesOneAfterTheOther(body1Name, body2Name) {
			removeBodyFromWorldAndBodiesArray(body1Name);
			setTimeout(() => removeBodyFromWorldAndBodiesArray(body2Name), 4000);
		}

		function compareTwoPlatformsAndBreak(platform1Name, platform2Name) {
			let v1 = findClosestCircleValueToPlank(allBodies[platform1Name]);
			let v2 = findClosestCircleValueToPlank(allBodies[platform2Name]);
			if (v1 < v2) {
				removeArrayOfBodies([platform1Name]);
			}
			else {
				removeArrayOfBodies([platform2Name]);
			}
		}

		function mergeOperationBasedOnPlatformsArrays(platformArray1, platformArray2) {
			let pi = 0;
			let pj = 0;
			while (platformArray1[pi] != undefined || platformArray2[pj] != undefined) {

				if (platformArray1[pi] == undefined) {
					let idx = pj;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray2[idx]);
					});
					pj += 1;
					continue;
				}

				if (platformArray2[pj] == undefined) {
					let idx = pi;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray1[idx]);
					});
					pi += 1;
					continue;
				}

				let p1Val = findClosestCircleValueToPlank(allBodies[platformArray1[pi]]);
				let p2Val = findClosestCircleValueToPlank(allBodies[platformArray2[pj]]);

				if (p1Val < p2Val) {
					let idx = pi;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray1[idx]);
					});
					pi += 1;
					continue;
				}
				else {
					let idx = pj;
					actionsWhenObjectsStopMoving.push(() => {
						removeBodyFromWorldAndBodiesArray(platformArray2[idx]);
					});
					pj += 1;
					continue;
				}

			}
		}

		let actionsWhenObjectsStopMoving = [
			() => {
				speak('First we split the array by half.');
				removeArrayOfBodies(
					[
						"l0Platform1",
						"l0Platform2",
						"l0Stopper1",
						"l0Stopper2"
					]
				);
			},
			() => {
				speak('We then split each of those halfs again.');
				removeArrayOfBodies([
					"level2_p2",
					"level2_p3",
					"level2_s2",
					"level2_s3",
					"level2_p4",
					"level2_s4",
					"level2_p1",
					"level2_s1"
				]);
			},
			() => {
				let v1 = findClosestCircleValueToPlank(allBodies.l2p2);
				let v2 = findClosestCircleValueToPlank(allBodies.l2p3);
				if (v1 < v2) {
					removeTwoBodiesOneAfterTheOther("l2p2", "l2p3");
				}
				else {
					removeTwoBodiesOneAfterTheOther("l2p3", "l2p2");
				}
			},
			() => {
				removeArrayOfBodies(["rect1027"]);
			},
			() => {
				compareTwoPlatformsAndBreak("rect57", "rect70");
			},
			() => {
				if (allBodies["rect57"] == undefined) {
					compareTwoPlatformsAndBreak("rect55", "rect70");
				}
				else {
					compareTwoPlatformsAndBreak("rect57", "rect55");
				}
			},
			() => {
				removeArrayOfBodies(["rect55", "rect70", "rect57"]);
			},
			() => {
				let v1 = findClosestCircleValueToPlank(allBodies.l2p4);
				let v2 = findClosestCircleValueToPlank(allBodies.l2p5);
				if (v1 < v2) {
					removeTwoBodiesOneAfterTheOther("l2p4", "l2p5");
				}
				else {
					removeTwoBodiesOneAfterTheOther("l2p5", "l2p4");
				}
			},
			() => {
				removeArrayOfBodies(["rect1033"]);
			},
			() => {
				compareTwoPlatformsAndBreak("rect110", "rect108");
			},
			() => {
				if (allBodies["rect108"] == undefined) {
					compareTwoPlatformsAndBreak("rect110", "rect112");
				}
				else {
					compareTwoPlatformsAndBreak("rect112", "rect108");
				}
			},
			() => {
				removeArrayOfBodies(["rect108", "rect110", "rect112"]);
			},
			() => {
				mergeOperationBasedOnPlatformsArrays(
					["rect132", "rect130", "rect128"],
					["rect88", "rect86", "rect84"]
				);
			}
		]

		function startDemo() {
			speak('Welcome to the merge sort demo!');
			Engine.run(engine);
			Render.run(render);

			setInterval(function(){ 
				let allStationary = true;
				arrayOfCircles.forEach(
					(item, idx) => {
						if (item.speed > 0.3) {
							allStationary = false;
						}
					}
				);
				if (allStationary && actionsWhenObjectsStopMoving[currentIndexOfActionWhenBodiesStopMoving] != undefined) {
					actionsWhenObjectsStopMoving[currentIndexOfActionWhenBodiesStopMoving]();
					currentIndexOfActionWhenBodiesStopMoving += 1;
				}
			}, 4000);
		}

		Swal.fire({
			title: '<strong>About</strong>',
			icon: 'info',
			html: `
				<ul style="text-align: left; line-height: 1.5em;">
					<li>Every time you <a href="javascript:location.reload();">refresh the page</a> random array is created & the merge sort process begins.</li>
					<li>This demo <b>has sound.</b> The computer explains what is going on at each step.</li>
					<li>Look <b>below the demo</b> for a video about how it was made, credits and other details.</li>
					<li>I am fully aware that this modal is annoying each time you refresh the page.</li>
				</ul>
			`,
			showCloseButton: true,
			focusConfirm: false,
			confirmButtonText:
				'<i class="fa fa-thumbs-up"></i> Great!',
			confirmButtonAriaLabel: 'Thumbs up, great!'
		}).then((result) => {
			if (result.value) {
				startDemo();
			}
		})

	</script>
</body>
</html>