<!DOCTYPE html>
<html>
<head>
	<title>Merge Sort :: A Visual Demo By Khoj Badami</title>
	<style type="text/css">
		canvas {
			border: 1px solid lightgrey;
		}
	</style>
</head>
<body>
	<script src="./libs/jquery-3.5.1.min.js"></script>
	<script src="./libs/matter.min.js"></script>
	<script src="./libs/decomp.min.js"></script>
	<script src="./libs/path-data-polyfill.js"></script>
	<script type="text/javascript">

		let allBodies = {};
		let currentIndexOfActionWhenBodiesStopMoving = 0;
		const mmToPxMupliplicationFactor = 3.78;

		function getColorFromSVGNode(svgNode) {
			let styleValue = $(svgNode).attr("style");
			let fillProperty = styleValue.split(";").find(
				( property ) => {
					return property.split(":")[0] == 'fill';
				}
			);
			return fillProperty.split(":")[1];
		}

		function bodyFromSvgPathMaker(svgPath, x, y, name) {
			this.svgPath = svgPath;
			
			this.x = x;
			
			this.y = y;

			this.name = name;
			
			this.makeBody = () => {
				let vertexSets = [];
				let points = Svg.pathToVertices(this.svgPath, 30);
				vertexSets.push(Vertices.scale(points, mmToPxMupliplicationFactor, mmToPxMupliplicationFactor));
				let body = Bodies.fromVertices(
					0, 0,
					vertexSets,
					{
	                    render: {
	                        fillStyle: getColorFromSVGNode(this.svgPath),
	                        strokeStyle: getColorFromSVGNode(this.svgPath),
	                        lineWidth: 1
	                    },
	                    isStatic : true
                    },
                    true
				);

				Matter.Body.setPosition(body, {
					x: this.x,
					y: this.y
				});

				let translationVector = Vector.sub(body.position, body.bounds.min);
				Matter.Body.translate(body, translationVector);

				allBodies[this.name] = body;
				return body;
			}
		}

		function bodyFromRectangle(svgRectangle, name) {

			this.svgRectangle = svgRectangle;

			this.name = name;

			this.makeBody = () => {
				let body = Bodies.rectangle(
					0, 0, 
					parseFloat($(this.svgRectangle).attr("width")) * mmToPxMupliplicationFactor, 
					parseFloat($(this.svgRectangle).attr("height")) * mmToPxMupliplicationFactor, 
						{
		                    render: {
		                        fillStyle: getColorFromSVGNode(this.svgRectangle),
		                        strokeStyle: getColorFromSVGNode(this.svgRectangle),
		                        lineWidth: 1
		                    },
		                    isStatic : true
	                    }
					);

				Matter.Body.setPosition(body, {
					x: parseFloat($(this.svgRectangle).attr("x")) * mmToPxMupliplicationFactor,
					y: parseFloat($(this.svgRectangle).attr("y")) * mmToPxMupliplicationFactor
				});

				let translationVector = Vector.sub(body.position, body.bounds.min);
				Matter.Body.translate(body, translationVector);

				allBodies[this.name] = body;
				return body;
			}

		}

		let Engine = Matter.Engine,
		    Render = Matter.Render,
		    World = Matter.World,
		    Bodies = Matter.Bodies,
		    Svg = Matter.Svg,
		    Vertices = Matter.Vertices,
		    Common = Matter.Common,
		    Vector = Matter.Vector;
		     
		let engine = Engine.create();
		 
		let render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: 1028,
                height: 1859,
                wireframes: false,
                background: '#ffffff'
            }
        });

        let world = engine.world;

		$.get( "./merge-sort-resources/static.svg", function( data ) {

			// Draw All Paths
			$(data).find('path').each(function(i, path) {
				let fullID = $(path).attr("id");
				let objectName = fullID.split("_")[0];
				let objectX = fullID.split("_")[1];
				let objectY = fullID.split("_")[2];
				let bodyMaker = new bodyFromSvgPathMaker(
					path, 
					parseFloat(objectX),
					parseFloat(objectY),
					objectName
				);
				World.add(world, bodyMaker.makeBody());
			});

			// Draw All Rectangles
			$(data).find('rect').each(function(i, svgRect) {
				let objectName = $(svgRect).attr("id");
				let bodyMaker = new bodyFromRectangle(
					svgRect,
					objectName
				);
				World.add(world, bodyMaker.makeBody());
			});

		});

		let circlePostions = [
			[378.245 + 10, 19.745],
			[419.445 + 10, 19.745],
			[460.645 + 10, 19.745],
			[501.845 + 10, 19.745],
			[543.045 + 10, 19.745],
			[584.245 + 10, 19.745]
		]

		let allCirclesWidthHeight = 37.510;

		let arrayOfCircles = circlePostions.map((item) => {
			let newX = allCirclesWidthHeight / 2 + item[0];
			let newY = allCirclesWidthHeight / 2 + item[1];
			let circle = Bodies.circle(newX, newY, allCirclesWidthHeight / 2);
			World.add(world, circle);
			return circle;
		});

        Engine.run(engine);
		Render.run(render);

		let actionsWhenObjectsStopMoving = [
			() => {
				World.remove(world, allBodies.l0Platform1);
				World.remove(world, allBodies.l0Platform2);
				World.remove(world, allBodies.l0Stopper1);
				World.remove(world, allBodies.l0Stopper2);
			},
			() => {
				World.remove(world, allBodies.level2_p2);
				World.remove(world, allBodies.level2_p3);
				World.remove(world, allBodies.level2_s2);
				World.remove(world, allBodies.level2_s3);
				World.remove(world, allBodies.level2_p4);
				World.remove(world, allBodies.level2_s4);
				World.remove(world, allBodies.level2_p1);
				World.remove(world, allBodies.level2_s1);
			}
		]

		setInterval(function(){ 
			let allStationary = true;
			arrayOfCircles.forEach(
				(item, idx) => {
					if (item.speed > 0.3) {
						allStationary = false;
					}
				}
			);
			if (allStationary && actionsWhenObjectsStopMoving[currentIndexOfActionWhenBodiesStopMoving] != undefined) {
				actionsWhenObjectsStopMoving[currentIndexOfActionWhenBodiesStopMoving]();
				currentIndexOfActionWhenBodiesStopMoving += 1;
			}
		}, 1000);

	</script>
</body>
</html>